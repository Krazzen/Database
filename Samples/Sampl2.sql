/** add_employee: 
This routine is used to add a new employee. 
Inputs: 
  name, home address, contact number, 
  email address, salary information (i.e., monthly salary for a full-time employee or hourly rate for a part-time employee), 
  date that the employee joined the company, the employee category (manager, administrator, or instructor), 
  and a (possibly empty) set of course areas. 
If the new employee is a manager, the set of course areas refers to the areas that are managed by the manager. 
If the new employee is an instructor, the set of course areas refers to the instructor’s specialization areas. 
The set of course areas must be empty if the new employee is a administrator; and non-empty, otherwise. 
The employee identifier is generated by the system.
**/
CREATE OR REPLACE PROCEDURE add_employee(ename TEXT, address TEXT, phone INT, email TEXT, salary_info NUMERIC, join_date DATE, category TEXT, course_area TEXT)
AS $$
DECLARE
    current_eid INT; 
BEGIN
        INSERT INTO Employees (ename, phone, address, email, join_date)
        Values (ename, phone, address, email, join_date)
        RETURNING eid INTO current_eid;
      IF category = 'administrator' THEN
        BEGIN 
            IF (course_area != NULL) THEN
                RAISE EXCEPTION 'Administrators cannot have course areas';
              ROLLBACK;
            END IF;
            INSERT INTO Full_Time_Emp (eid, monthly_salary) VALUES (current_eid,salary_info);
            INSERT INTO Administrators(eid) VALUES(current_eid);
        END;
      ELSIF category = 'manager' THEN
        BEGIN
            INSERT INTO Full_Time_Emp (eid, monthly_salary) VALUES (current_eid,salary_info);
            INSERT INTO Managers(eid) VALUES (current_eid);
            INSERT INTO Course_areas  VALUES (course_area,current_eid);
        END;    
      ELSIF category = 'part-time instructor' THEN
        BEGIN
            INSERT INTO Part_Time_Emp (eid, hourly_rate) VALUES (current_eid,salary_info);
            INSERT INTO Instructors (eid) VALUES (current_eid);
            INSERT INTO Specializes VALUES (course_area,current_eid);
        END;
      ELSIF category = 'full-time instructor' THEN
        BEGIN
            INSERT INTO Full_Time_Emp (eid, monthly_salary) VALUES (current_eid,salary_info);
            INSERT INTO Instructors (eid) VALUES (current_eid);
            INSERT INTO Specializes  VALUES (course_area,current_eid);
        END;    
      ELSE
          RAISE EXCEPTION 'Allowed values for category: administrator, manager, part-time instructor, full-time instructor.';
          ROLLBACK;
      END IF;
END;
$$ LANGUAGE plpgsql;

--remove_employee: This routine is used to update an employee’s departed date a non-null value. The inputs to the routine is an employee identifier and a departure date. The update operation is rejected if any one of the following conditions hold: (1) the employee is an administrator who is handling some course offering where its registration deadline is after the employee’s departure date; (2) the employee is an instructor who is teaching some course session that starts after the employee’s departure date; or (3) the employee is a manager who is managing some area.
CREATE OR REPLACE PROCEDURE remove_employee(update_eid INT,update_depart_date DATE)
AS $$
  UPDATE Employees
  SET depart_date = update_depart_date
  WHERE eid = update_eid;
$$ LANGUAGE sql;

--add_customer: This routine is used to add a new customer. The inputs to the routine include the following: name, home address, contact number, email address, and credit card details (credit card number, expiry date, CVV code). The customer identifier is generated by the system.
CREATE OR REPLACE PROCEDURE add_customer(cust_name TEXT, address TEXT, phone TEXT, email TEXT, credit_card_number INT, expiry_date DATE, CVV CHAR)
AS $$
DECLARE
  curr_cust_id Customers.cust_id%TYPE;
BEGIN 
  INSERT INTO Customers(cust_name,address,email,phone)
  Values(cust_name,address,email,phone) RETURNING cust_id INTO curr_cust_id;
  INSERT INTO Credit_cards(credit_card_number, CVV, owned_by, expiry_date)
  Values(credit_card_number,CVV,curr_cust_id,expiry_date);  
END;
$$ LANGUAGE plpgsql;


--update_credit_card: This routine is used when a customer requests to change his/her credit card details. The inputs to the routine include the customer identifier and his/her new credit card details (credit card number, expiry date, CVV code).
CREATE OR REPLACE PROCEDURE update_credit_card(update_cust_id INT, update_credit_card_number TEXT, update_expiry_date DATE, update_CVV CHAR)
AS $$
  UPDATE Credit_cards
  SET  credit_card_number= update_credit_card_number, 
  expiry_date = update_expiry_date,
  CVV = update_CVV
  WHERE owned_by = update_cust_id;
$$ LANGUAGE sql;

--add_course: This routine is used to add a new course. The inputs to the routine include the following: course title, course description, course area, and duration. The course identifier is generated by the system.
CREATE OR REPLACE PROCEDURE add_course(title TEXT, description TEXT, area_name TEXT, duration INT)
AS $$
  INSERT INTO Courses(title,duration,description,area_name)
  Values(title,duration,description,area_name);
$$ LANGUAGE sql;

--find_instructors: This routine is used to find all the instructors who could be assigned to teach a course session. The inputs to the routine include the following: course identifier, session date, and session start hour. The routine returns a table of records consisting of employee identifier and name.
CREATE OR REPLACE FUNCTION find_instructors (find_course_id INT, session_date DATE,session_start_hour TIME)
RETURNS TABLE(eid integer,ename text)
AS $$
	WITH instructor_with_course AS (
		SELECT * 
		FROM Specializes 
		JOIN Employees USING (eid)
		JOIN Courses USING (area_name)
		WHERE Courses.course_id=find_course_id
	)
	SELECT i1.eid,i1.ename 
	FROM instructor_with_course i1 
	WHERE NOT EXISTS(
	    SELECT 1
	    FROM Sessions s1
	    WHERE i1.eid = s1.conducting_instructor
	    AND session_date = s1.s_date
	    AND session_start_hour > s1.start_time
	    AND session_start_hour < s1.end_time
	);
$$ LANGUAGE sql;

/** get_available_instructors: 
    This routine is used to retrieve the availability information of instructors who could be assigned to teach a specified course. 
    Inputs: 
        course identifier, start date, and end date. 
    Returns: 
        table of records consisting of the following information: 
        employee identifier, name, total number of teaching hours that the instructor has been assigned for this month, 
        day (which is within the input date range [start date, end date]), 
        and an array of the available hours for the instructor on the specified day. 
        The output is sorted in ascending order of employee identifier and day, and the array entries are sorted in ascending order of hour.
**/
CREATE OR REPLACE FUNCTION avail_from_busy_hours (busy_hours TIME[][], rest INT)
RETURNS TABLE (start_time TIME, end_time TIME)
AS $$
    DECLARE
        am_end TIME     := TIME '12:00:000';
        pm_start TIME   := TIME '14:00:000';
        t TIME[];
    BEGIN
        start_time := TIME '09:00:000';
        IF CARDINALITY(busy_hours) > 0 THEN
            FOREACH t SLICE 1 IN ARRAY busy_hours
            LOOP
                t[1] := t[1] - (rest * interval '1 hour');
                t[2] := t[2] + (rest * interval '1 hour');
                IF t[1] > am_end THEN
                    end_time := am_end;
                    RETURN NEXT;
                    start_time := pm_start;
                END IF;
                end_time := t[1];
                RETURN NEXT;
                IF t[2] >= am_end THEN
                    start_time := greatest(t[2], pm_start);
                ELSE
                    start_time := t[2];
                END IF;
            END LOOP;
        END IF; 
        IF start_time < am_end THEN
            end_time := am_end;
            RETURN NEXT;
            start_time := pm_start;
        END IF;
        IF start_time < TIME '18:00:000' THEN
            end_time := TIME '18:00:000';
            RETURN NEXT;
        END IF;
        RETURN;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_available_instructors (cid INT, start_date DATE,end_date DATE)
RETURNS TABLE (eid INT, ename TEXT, total_assigned_hours NUMERIC, available_day DATE, available_hours TIME[][])
AS $$
    WITH date_range AS (
        SELECT generate_series(start_date::timestamp, end_date, '1 day')::date AS day
    ), specializing_instructors AS (
        SELECT Employees.eid, Employees.ename 
        FROM Employees
        JOIN Specializes USING (eid)
        WHERE 
            Specializes.area_name = (
                SELECT Courses.area_name FROM Courses WHERE Courses.course_id = cid
            ) AND Employees.depart_date >= end_date
    ), Instructor_busy_hours AS (
        SELECT SI.eid, SI.ename, S.total_assigned_hours, date_range.day, 
            CASE WHEN busy_hours is NULL THEN ARRAY[]::TIME[][] ELSE busy_hours END as busy_hours
        FROM specializing_instructors SI
        CROSS JOIN date_range
        LEFT OUTER JOIN (
            SELECT 
                Sessions.conducting_instructor as eid,
                Sessions.s_date as day, 
                date_part(
                    'hour', sum(Sessions.end_time - Sessions.start_time)
                )::NUMERIC AS total_assigned_hours,
                array_agg(ARRAY[start_time, end_time] ORDER BY start_time ASC) as busy_hours
            FROM Sessions
            WHERE Sessions.s_date >= start_date AND Sessions.s_date <= end_date
            GROUP BY (eid, s_date)
        ) S ON S.eid = SI.eid AND S.day = date_range.day
        ORDER BY SI.eid ASC, date_range.day ASC
    )
    SELECT eid, ename, total_assigned_hours, day as available_day,
        (SELECT array_agg(ARRAY[B.start_time, B.end_time]) FROM avail_from_busy_hours(busy_hours, 1) B) as available_hours
    FROM Instructor_busy_hours;
$$ LANGUAGE sql;

/** find_rooms:
    This routine is used to find all the rooms that could be used for a course session. 
    Inputs:
        session date, session start hour, and session_end_hour.
    Returns:
        table of room identifiers.
**/
CREATE OR REPLACE FUNCTION find_rooms (session_date DATE, session_start_hour TIME, session_end_hour TIME)
RETURNS TABLE(rid INT)
AS $$
  SELECT r1.rid
  FROM Rooms r1 
  WHERE NOT EXISTS(
    SELECT 1
    FROM Sessions s1
    WHERE s1.conducted_in = r1.rid
                AND s1.s_date = session_date
                AND ((s1.start_time > session_end_hour) OR (s1.end_time < session_start_hour))       );    
$$ LANGUAGE sql;

/** get_available_rooms:
    This routine is used to retrieve the availability information of rooms for a specific duration.
    Inputs:
        start date and an end date. 
    Returns:
        a table of records consisting of: room identifier, room capacity, 
            day (which is within the input date range [start date, end date]), 
            and an array of the hours that the room is available on the specified day. 
        The output is sorted in ascending order of room identifier and day, and the array entries are sorted in ascending order of hour.
    
    Total assigned hours: 
        does not make sense to be for that month because start_date, end_date is across months.
        does not make sense to be sum of total because does not convey any useful information.
        Should be: for that period, so we can allocate those with less hours new sessions.
*/
CREATE OR REPLACE FUNCTION get_available_rooms (start_date DATE, end_date DATE)
RETURNS TABLE (rid INT, room_capacity INT, available_day DATE, available_hours TIME[][])
AS $$
    WITH date_range AS (
        SELECT generate_series(start_date::timestamp, end_date, '1 day')::date AS day
    ), Room_busy_hours AS (
        SELECT Rooms.rid, Rooms.seating_capacity, date_range.day as available_day, 
            CASE WHEN busy_hours is NULL THEN ARRAY[]::TIME[][] ELSE busy_hours END as busy_hours
        FROM Rooms
        CROSS JOIN date_range
        LEFT OUTER JOIN (
            SELECT s_date, conducted_in as rid,
                array_agg(ARRAY[start_time, end_time] ORDER BY start_time ASC) as busy_hours
            FROM Sessions
            WHERE Sessions.s_date >= start_date AND Sessions.s_date <= end_date
            GROUP BY (rid, s_date)
        ) S ON S.rid = Rooms.rid AND S.s_date = date_range.day
        ORDER BY Rooms.rid ASC, date_range.day ASC
    )
    SELECT rid, seating_capacity, available_day,
        (SELECT array_agg(ARRAY[B.start_time, B.end_time]) FROM avail_from_busy_hours(busy_hours, 0) B) as available_hours
    FROM Room_busy_hours;
$$ LANGUAGE sql;

/** add_course_offering:
    This routine is used to add a new offering of an existing course. 
    Inputs:
        course offering identifier (Offering.launch_date), launch date, 
        course identifier (Course.course_id),
        course fees, registration deadline,target number of registrations, administrator’s identifier, 
        and information for each session (session date, session start hour, and room identifier). 
    Validity Checks:
        If the input course offering information is valid, the routine will assign instructors for the sessions.
        If a valid instructor assignment exists, the routine will perform the necessary updates to add the course offering;
            otherwise, the routine will abort the course offering addition.
        Note that the seating capacity of the course offering must be at least equal to the course offering’s target number of registrations.
**/
/**
drop table if exists source cascade;
drop function if exists process(dataset) cascade;
drop type if exists dataset cascade;

CREATE TYPE dataset AS (  
    session_date DATE ,  
    session_start_hour TIME,
    rid INT);

CREATE OR REPLACE PROCEDURE add_course_offering(
    course_id INT, course_fee NUMERIC, launch_date DATE, registration_deadline DATE, target_number_registrations INT, aid INT, 
    sess_info dataset[])
AS $$
    DECLARE
        offering_start_date Offerings.start_date%TYPE;
        offering_end_date Offerings.end_date%TYPE;
        seating_capacity Offerings.seating_capacity%TYPE;
        invalid_rids INTEGER[];
    BEGIN
        /** All room ids provided must be valid 
        SELECT ARRAY(
            SELECT rid FROM (Rooms FULL OUTER JOIN unnest(sess_info)) USING (rid) WHERE seating_capacity IS NULL
        ) INTO invalid_rids;
        IF array_length(invalid_rids, 1) > 0 THEN
            RAISE EXCEPTION "Invalid rids included in session_info: %", invalid_rids;
        END IF;
        /** seating capacity of the course offering must be at least equal to the course offering’s target number of registrations 
        SELECT min(unnest(sess_info).session_date), max(unnest(sess_info).session_date), sum(Rooms.seating_capacity)
            INTO offering_start_date, offering_end_date, sezting_capacity
            FROM unnest(sess_info)
            JOIN Rooms USING (rid);
        IF seating_capacity < target_number_registrations THEN
            RAISE EXCEPTION "seating_capacity (%) is less than target_number_registrations (%)", seating_capacity, target_number_registrations;
        END IF;
        /** If the input course offering information is valid, the routine will assign instructors for the sessions. 
        SELECT get_available_instructors(course_id, offering_start_date, offering_end_date);
        BEGIN;
        INSERT INTO Offerings(course_id, launch_date, registration_deadline, start_date, end_date, target_number_registrations, seating_capacity, fees, eid)
            VALUES (course_id, launch_date, registration_deadline, offering_start_date, offering_end_date, target_number_registrations, , course_fee, aid);
            /** If a valid instructor assignment exists, 
                the routine will perform the necessary updates to add the course offering;
                otherwise, the routine will abort the course offering addition.
            
            FOR session IN sess_info:
        COMMIT;
    END;  
$$ LANGUAGE plpgsql;
**/

/** add_course_package: 
    This routine is used to add a new course package for sale. 
    Inputs: 
        package name, number of free course sessions, 
        start and end date indicating the duration that the promotional package is available for sale, 
        price of the package. 
    The course package identifier is generated by the system. 
    If the course package information is valid, the routine will perform the necessary updates to add the new course package.
**/
CREATE OR REPLACE PROCEDURE add_course_package(
    package_name TEXT, num_free_registrations INT, sale_start_date DATE, sale_end_date DATE, price NUMERIC
)
AS $$
    /** Course Packages does not have any trigger-enforced constraints **/
    INSERT INTO Course_packages(package_name, num_free_registrations, sale_start_date, sale_end_date, price)
    Values(package_name, num_free_registrations, sale_start_date, sale_end_date, price);
$$ LANGUAGE sql;

/** get_available_course_packages: 
    This routine is used to retrieve the course packages that are available for sale. 
    Returns a table with records for each available course package: 
        package name, number of free course sessions, end date for promotional package, and the price of the package.
**/
CREATE OR REPLACE FUNCTION get_available_course_packages()
RETURNS TABLE (package_name TEXT, num_free_registrations INT, sale_end_date DATE, price NUMERIC)
AS $$
    SELECT package_name, num_free_registrations, sale_end_date, price
    FROM Course_packages
    WHERE sale_start_date <= (SELECT CURRENT_DATE) and sale_end_date >= (SELECT CURRENT_DATE);
$$ LANGUAGE sql;

/** buy_course_package: 
    This routine is used when a customer requests to purchase a course package. 
    If the purchase transaction is valid, the routine will process the purchase with the necessary updates (e.g., payment).
    Inputs:
        customer and course package identifiers. 
    No return.

    Issue: each customer has one or more credit cards. 
    Solution: Automatically use the latest added credit card.
**/
CREATE OR REPLACE PROCEDURE buy_course_package(cust_id INT, new_package_id INT)
AS $$
DECLARE
    cc_number TEXT;
    buy_date DATE;
    num_remaining_redemptions INT;
BEGIN
    cc_number := (SELECT credit_card_number FROM Credit_cards WHERE Credit_cards.owned_by = cust_id ORDER BY Credit_cards.from_date ASC LIMIT 1);
    buy_date := (SELECT CURRENT_DATE);
    num_remaining_redemptions := (SELECT num_free_registrations FROM Course_packages WHERE Course_packages.package_id = new_package_id);
    INSERT INTO Buys (credit_card_number, owned_by, buy_date,num_remaining_redemptions, package_id) VALUES (cc_number, cust_id, buy_date, num_remaining_redemptions,new_package_id);
END;
$$ LANGUAGE plpgsql;

/** get_my_course_package: 
    This routine is used when a customer requests to view his/her active/partially active course package.
    Input:
        customer identifier. 
    Returns: (as JSON value) 
        package name, purchase date, price of package, 
        number of free sessions included in the package, 
        number of sessions that have not been redeemed, and 
        information for each redeemed session (course name, session date, session start hour). 
        The redeemed session information is sorted in ascending order of session date and start hour.
**/
CREATE OR REPLACE FUNCTION get_my_course_package(cust_id INT)
RETURNS TEXT
AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM Current_Active_Packages CAP WHERE CAP.owned_by = cust_id) THEN
        RETURN '{}'::json;
    END IF;
    RETURN (
        WITH current_active_package AS (
            SELECT * 
            FROM Current_Active_Packages CAP
            WHERE CAP.owned_by = cust_id
        ), redeemed_sessions AS (
            SELECT Courses.title AS course_name, Sessions.s_date as session_date, Sessions.start_time AS session_start_hour
            FROM Redeems
            JOIN current_active_package USING (package_id, buy_date, credit_card_number, owned_by)
            JOIN Sessions USING (sid, launch_date, course_id)
            JOIN Courses USING (course_id)
            WHERE Redeems.buy_date = current_active_package.buy_date
                AND Redeems.credit_card_number = current_active_package.credit_card_number
            ORDER BY Sessions.s_date ASC, Sessions.start_time ASC
        )
        SELECT json_build_object(
            'package_name', Course_packages.package_name,
            'purchase_date', current_active_package.buy_date,
            'price_of_package', Course_packages.price,
            'num_free_sessions', Course_packages.num_free_registrations,
            'num_remaining_redemptions', current_active_package.num_remaining_redemptions,
            'redeemed_sessions',  (
                SELECT json_agg(
                    json_build_array(course_name, to_char((session_date + session_start_hour)::TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS'))
                    )
                FROM redeemed_sessions
            )
        ) AS my_course_package
        FROM Course_packages 
        JOIN current_active_package ON Course_packages.package_id = current_active_package.package_id
    );
END
$$ LANGUAGE plpgsql;

/** get_available_course_offerings: 
This routine is used to retrieve all the available course offerings that could be registered. 
Returns:
    for each course offering: 
        course title, course area, start date, end date, registration deadline, course fees, and the number of remaining seats. 
The output is sorted in ascending order of registration deadline and course title.
**/
CREATE OR REPLACE FUNCTION get_available_course_offerings()
RETURNS TABLE (
    course_title TEXT, course_area TEXT, start_date DATE, end_date DATE, registration_deadline DATE, course_fees NUMERIC, num_remaining_seats BIGINT
)
AS $$
    WITH registered_sessions AS (
        SELECT Offerings.course_id, Offerings.launch_date, count(*) as registration_count
        FROM Offerings
        NATURAL JOIN Sessions
        NATURAL JOIN Registers
        GROUP BY Offerings.course_id, Offerings.launch_date
    ), redeemed_sessions AS (
        SELECT Offerings.course_id, Offerings.launch_date, count(*) as redeem_count
        FROM Offerings
        NATURAL JOIN Sessions
        NATURAL JOIN Redeems
        GROUP BY Offerings.course_id, Offerings.launch_date
    ), current_capacity AS (
        SELECT Reg.course_id, Reg.launch_date, COALESCE(Reg.registration_count,0) + COALESCE(Red.redeem_count,0) as current_count
        FROM registered_sessions Reg
        FULL OUTER JOIN redeemed_sessions Red ON Reg.course_id = Red.course_id AND Reg.launch_date = Red.launch_date
    )
    SELECT Courses.title as course_title, Courses.area_name as course_area, Offerings.start_date as start_date, Offerings.end_date as end_date, 
        Offerings.registration_deadline, Offerings.fees as course_fees, Offerings.seating_capacity - COALESCE(current_capacity.current_count,0) as num_remaining_seats
    FROM Courses
    JOIN Offerings USING (course_id)
    RIGHT OUTER JOIN current_capacity USING (course_id, launch_date)
    WHERE Offerings.seating_capacity - COALESCE(current_capacity.current_count,0) > 0
    ORDER BY registration_deadline ASC, course_title ASC;
$$ LANGUAGE sql;

/* 16. get_available_course_sessions: 
    This routine is used to retrieve all the available sessions for a course offering that could be registered. 
    INPUT:
        course offering identifier.
    RETURN:
        table of records for each available session:
            session date, session start hour, instructor name, and number of remaining seats for that session. 
        The output is sorted in ascending order of session date and start hour.
    -- Assumption: start hour is in 24 hour format
 */
CREATE OR REPLACE FUNCTION get_available_course_sessions(in_course_id INT, in_launch_date DATE)
RETURNS TABLE(session_date DATE, start_hour TIME, instructor INT, num_remaining_seats BIGINT)
AS $$
    BEGIN
    IF (SELECT registration_deadline FROM Offerings WHERE Offerings.course_id = in_course_id AND Offerings.launch_date = in_launch_date) > CURRENT_DATE THEN
        RAISE EXCEPTION 'Course offering (%, %) can no longer be registered.', in_course_id, in_launch_date;
    END IF;
    RETURN QUERY
    WITH registered_sessions AS (
        SELECT Sessions.sid, Sessions.course_id, Sessions.launch_date, COUNT(*) as registration_count
        FROM Sessions
        JOIN Registers USING (sid, course_id, launch_date)
        WHERE Sessions.course_id = in_course_id AND Sessions.launch_date = in_launch_date
        GROUP BY (Sessions.sid, Sessions.course_id, Sessions.launch_date)
    ), redeemed_sessions AS (
        SELECT Sessions.sid, Sessions.course_id, Sessions.launch_date, COUNT(*) as redeem_count
        FROM Sessions
        JOIN Redeems USING (sid, course_id, launch_date)
        WHERE Sessions.course_id = in_course_id AND Sessions.launch_date = in_launch_date
        GROUP BY (Sessions.sid, Sessions.course_id, Sessions.launch_date)
    )
    SELECT S.s_date, S.start_time as start_hour, S.conducting_instructor as instructor, 
        S.seating_capacity - COALESCE(registration_count, 0) - COALESCE(redeem_count, 0) as num_remaining_seats
    FROM (
        SELECT *
        FROM Sessions
        JOIN Rooms ON Sessions.conducted_in = Rooms.rid
        WHERE Sessions.course_id = in_course_id AND Sessions.launch_date = in_launch_date
        ) AS S
    FULL OUTER JOIN registered_sessions USING (sid, course_id, launch_date) 
    FULL OUTER JOIN redeemed_sessions USING (sid, course_id, launch_date)
    ORDER BY s_date ASC, start_hour ASC;
    END;
$$ LANGUAGE plpgsql;

/* 17. register_session
    This routine is used when a customer requests to register for a session in a course offering. 
	INPUT:
		customer identifier, course offering identifier, session number, and payment method (credit card or redemption from active package).
    NO RETURN
	If the registration transaction is valid, this routine will process the registration with the necessary updates (e.g., payment/redemption). 
	Assumption: 
		1. date where function is called is redemption/registration date,
	    2. if there is more than one offering of the same course id, i.e. launch date is diff, choose the one with the nearest registration deadline
 */
CREATE OR REPLACE PROCEDURE register_session(IN cust_id INT, IN in_course_id INT, IN in_sid INT, IN payment_method TEXT, IN in_launch_date DATE)
AS $$
  DECLARE
      session_to_register RECORD;
      credit_card_num TEXT;
  BEGIN
        IF (NOT EXISTS(SELECT * FROM Sessions WHERE Sessions.course_id = in_course_id AND Sessions.launch_date = in_launch_date AND Sessions.sid = in_sid)) THEN
            RAISE EXCEPTION 'No course with ID: (%) launched on (%) or course does not have session ID: (%)', in_course_id, in_launch_date, in_sid;
        ELSIF (CURRENT_DATE > (SELECT registration_deadline FROM Offerings WHERE Offerings.course_id = in_course_id AND Offerings.launch_date = in_launch_date)) THEN
            RAISE EXCEPTION 'Unable to register for course (%) launched on (%) because registration deadline has passed', in_course_id, in_launch_date;
        ELSE
            IF (payment_method = 'redemption') THEN
                SELECT package_id, buy_date, credit_card_number INTO session_to_register FROM Current_Active_Packages WHERE cust_id = owned_by;

                IF (session_to_register.package_id IS NULL) THEN
                    RAISE EXCEPTION 'Customer does not have any active packages. No session to redeem';
                ELSE
                    INSERT INTO Redeems(redeem_date, package_id, buy_date, credit_card_number, owned_by, course_id, launch_date, sid)
                    Values(date_now, session_to_register.package_id, session_to_register.buy_date, session_to_register.credit_card_number, cust_id, in_course_id, in_launch_date, in_sid);
                END IF;

                IF ((SELECT num_remaining_redemptions FROM Buys WHERE owned_by = cust_id) > 0) THEN
                    /* decrease remaining redemptions */
                    UPDATE Buys
                    SET num_remaining_redemptions = num_remaining_redemptions - 1
                    WHERE owned_by = cust_id AND session_to_register.buy_date = buy_date AND session_to_register.credit_card_number = credit_card_number;
                ELSE RAISE EXCEPTION 'No more remaining redemptions';
                END IF;
            ELSIF (payment_method = 'credit card') THEN
                credit_card_num := (SELECT credit_card_number FROM Credit_cards WHERE owned_by = cust_id ORDER BY from_date DESC LIMIT 1);
                INSERT INTO Registers(sid, course_id, launch_date, registration_date, credit_card_number, owned_by)
                Values(in_sid, in_course_id, in_launch_date, CURRENT_DATE, credit_card_num, cust_id);
            ELSE
                RAISE EXCEPTION 'Invalid payment method';
            END IF;
        END IF;
  END;
$$ LANGUAGE plpgsql;

/* 18. get_my_registrations:
    This routine is used when a customer requests to view his/her active course registrations (i.e, registrations for course sessions that have not ended).
    INPUT:
        customer identifier. 
    RETURN:
        table of records for each active registration session: 
            course name, course fees, session date, session start hour, session duration, and instructor name. 
        The output is sorted in ascending order of session date and session start hour.
*/
CREATE OR REPLACE FUNCTION get_my_registrations(IN in_cust_id INT)
RETURNS TABLE(title TEXT, fees NUMERIC, s_date DATE, start_hour TIME, duration interval, instructor INT)
AS $$
    SELECT title, fees, s_date, start_time AS start_hour, (end_time - start_time) AS duration, conducting_instructor AS instructor
    FROM Courses NATURAL JOIN Offerings NATURAL JOIN Sessions NATURAL JOIN Registers
    WHERE owned_by = in_cust_id AND (s_date - interval '0 days' >= (SELECT CURRENT_DATE))
    UNION
    SELECT title, fees, s_date, start_time AS start_hour, (end_time - start_time) AS duration, conducting_instructor AS instructor
    FROM Courses NATURAL JOIN Offerings NATURAL JOIN Sessions NATURAL JOIN Redeems
    WHERE owned_by = in_cust_id AND (s_date - interval '0 days' >= (SELECT CURRENT_DATE)) 
    ORDER BY s_date, start_hour;
$$ LANGUAGE sql;

/** 19. update_course_session: 
	This routine is used when a customer requests to change a registered course session to another session. T
	Inputs: 
		customer identifier, course offering identifier, and new session number.
	If the update request is valid and there is an available seat in the new session, the routine will process 
	the request with the necessary updates.
	-- Assume:
		date of registration changes to new date to match changing of session 
		checks for validity are done by triggers
**/
CREATE OR REPLACE PROCEDURE update_course_session(IN cust_id INT, IN new_course_id INT, IN new_launch_date DATE, IN new_sid INT)
AS $$
    UPDATE Registers
    SET sid = new_sid, registration_date = (SELECT CURRENT_DATE)
    WHERE owned_by = cust_id AND course_id = new_course_id AND launch_date = new_launch_date;

    UPDATE Redeems
    SET sid = new_sid, redeem_date = (SELECT CURRENT_DATE)
    WHERE owned_by = cust_id AND course_id = new_course_id AND launch_date = new_launch_date;
$$ LANGUAGE sql;

/** 20. cancel_registration: 
	This routine is used when a customer requests to cancel a registered course session. 
	Inputs:
		customer identifier, and course offering identifier.
	If the cancellation request is valid, the routine will process the request with the necessary updates. 
**/
CREATE OR REPLACE PROCEDURE cancel_registration(IN cust_id INT, IN in_course_id INT, IN in_launch_date DATE)
AS $$
    DECLARE
        refund_amt NUMERIC;
        register_record RECORD;
        redeem_record RECORD;
        redeem_buys RECORD;
    BEGIN
        -- customer can register for <= 1 session for each course
        SELECT * INTO register_record FROM Registers NATURAL JOIN Sessions S WHERE cust_id = owned_by AND S.course_id = course_id AND launch_date = in_launch_date;
        SELECT * INTO redeem_record FROM Redeems NATURAL JOIN Sessions S WHERE cust_id = owned_by AND S.course_id = course_id AND launch_date = in_launch_date;
        -- Assume date of cancellation is current date and customer either registers or redeems for a specific offering but not both
        IF (register_record.s_date >= CURRENT_DATE + '7 days'::interval) THEN
            refund_amt := (SELECT ROUND(0.9 * fees, 2) FROM Offerings WHERE course_id = in_course_id AND launch_date = in_launch_date);
            INSERT INTO Cancels(cancel_date, cust_id, sid, course_id, launch_date, refund_amt, package_credit)
            Values(CURRENT_DATE, 
                cust_id, 
                register_record.sid,
                in_course_id,
                in_launch_date,
                refund_amt,
                NULL);

            DELETE FROM Registers
            WHERE EXISTS(
                SELECT 1
                FROM Registers
                WHERE owned_by = cust_id AND course_id = in_course_id);
        ELSIF (redeem_record.s_date >= CURRENT_DATE + '7 days'::interval) THEN
            SELECT num_remaining_redemptions, package_id INTO redeem_buys FROM Redeems NATURAL JOIN Buys WHERE course_id = in_course_id AND owned_by = cust_id AND launch_date = in_launch_date;
            INSERT INTO Cancels(cancel_date, cust_id, sid, course_id, launch_date, refund_amt, package_credit)
            Values(CURRENT_DATE, 
                    cust_id, 
                    redeem_record.sid,
                    in_course_id,
                    in_launch_date,
                    NULL,
                    1);

            /* Update buys table */
            UPDATE Buys
            SET num_remaining_redemptions = num_remaining_redemptions + 1
            WHERE package_id = redeem_buys.package_id;

            DELETE FROM Redeems
            WHERE EXISTS(
                SELECT 1
                FROM Redeems
                WHERE owned_by = cust_id AND course_id = in_course_id);
        ELSIF (register_record.s_date >= CURRENT_DATE) OR (redeem_record.s_date >= CURRENT_DATE) THEN
            RAISE EXCEPTION 'Cannot cancel registration after session has started'; 
        ELSIF (CURRENT_DATE < register_record.registration_date) OR (CURRENT_DATE < redeem_record.buy_date) THEN
            RAISE EXCEPTION 'Cannot cancel registration before transaction date!';
        ELSE
            RAISE EXCEPTION 'Session not found';
        END IF;
    END;
$$ LANGUAGE plpgsql;

/* 21. update_instructor
	This routine is used to change the instructor for a course session. 
	Inputs:
		course offering identifier, session number, and identifier of the new instructor. 
	If the course session has not yet started and the update request is valid, the routine will process the request with the necessary updates. 
*/
CREATE OR REPLACE PROCEDURE update_instructor(target_course_id INT, target_launch_date DATE, target_session_id INT, update_instructor_id INT)
AS $$
	DECLARE
        start_time TIME;
        s_date DATE;
	BEGIN
	SELECT Sessions.start_time, Sessions.s_date
		INTO start_time, s_date
        FROM Sessions
        WHERE Sessions.sid = target_session_id AND Sessions.course_id = target_course_id AND Sessions.launch_date = target_launch_date;
	IF ((SELECT CURRENT_TIMESTAMP) > s_date + start_time) THEN
        RAISE EXCEPTION 'Session has already started';
    END IF;
		UPDATE Sessions
		SET conducting_instructor = update_instructor_id
		WHERE course_id = target_course_id AND sid = target_session_id;
	END;
$$ LANGUAGE plpgsql;

/* 22. update_room: This routine is used to change the room for a course session. 
	Inputs: 
		course offering identifier (course_id and launch_date), session number, and identifier of the new room.
	If the course session has not yet started and the update request is valid, the routine will process the request with the necessary updates. 
	Note that update request should not be performed if the number of registrations for the session exceeds the seating capacity of the new room.
*/
CREATE OR REPLACE PROCEDURE update_room(target_course_id INT, target_launch_date DATE, target_session_id INT, update_room_id INT)
AS $$
	DECLARE
        start_time TIME;
        s_date DATE;
	BEGIN
	SELECT Sessions.start_time, Sessions.s_date
		INTO start_time, s_date
        FROM Sessions
        WHERE Sessions.sid = target_session_id AND Sessions.course_id = target_course_id AND Sessions.launch_date = target_launch_date;
	IF ((SELECT CURRENT_TIMESTAMP) > s_date + start_time) THEN
        RAISE EXCEPTION 'Session has already started';
    END IF;
		UPDATE Sessions
		SET conducted_in = update_room_id
		WHERE course_id = target_course_id AND launch_date = target_launch_date AND sid = target_session_id;
	END;
$$ LANGUAGE plpgsql;

/* 23. remove_session:
	This routine is used to remove a course session. 
	Inputs: 
		course offering identifier (course_id and launch_date) and session number.
	If the course session has not yet started and the request is valid, the routine will process the request with the necessary updates. 
	The request must not be performed if there is at least one registration for the session.
	Note that the resultant seating capacity of the course offering could fall below the course offering’s target number of registrations, which is allowed.
*/
CREATE OR REPLACE PROCEDURE remove_session(target_course_id INT, target_launch_date DATE, target_session_id INT)
AS $$
	DECLARE
        start_time TIME;
        s_date DATE;
	BEGIN
	SELECT Sessions.start_time, Sessions.s_date
		INTO start_time, s_date
        FROM Sessions
        WHERE Sessions.sid = target_session_id AND Sessions.course_id = target_course_id AND Sessions.launch_date = target_launch_date;
	IF ((SELECT CURRENT_TIMESTAMP) > s_date + start_time) THEN
        RAISE EXCEPTION 'Session has already started';
    END IF;
	DELETE FROM Sessions
	WHERE course_id = target_course_id AND launch_date = target_launch_date AND sid = target_session_id;
	END;
$$ LANGUAGE plpgsql;

/* 24. add_session:
	This routine is used to add a new session to a course offering. 
	Inputs:
		course offering identifier (consisting of course_id and launch_date), new session number,
		new session day, new session start hour, new session end hour, instructor identifier for new session,
		and room identifier for new session. 
	If the course offering’s registration deadline has not passed and the the addition request is valid, 
	the routine will process the request with the necessary updates. 
*/
CREATE OR REPLACE PROCEDURE add_session(target_course_id INT, target_launch_date DATE, new_session_day DATE, new_session_starttime TIME, new_session_endtime TIME, instructor_id INT, room_id INT)
AS $$
	DECLARE
        reg_dead DATE;
        curr_highest_sid INT;
	BEGIN
	SELECT Offerings.registration_deadline
		INTO reg_dead
        FROM Offerings
        WHERE Offerings.course_id = target_course_id AND Offerings.launch_date = target_launch_date;
	IF (reg_dead > new_session_day) THEN
        RAISE EXCEPTION 'Course offering’s registration deadline has passed.';
    END IF;
	SELECT MAX(sid) FROM Sessions INTO curr_highest_sid;
	INSERT INTO Sessions
	Values(curr_highest_sid + 1, new_session_day, new_session_starttime, new_session_endtime, target_course_id, target_launch_date, room_id, instructor_id);
	END;
$$ LANGUAGE plpgsql;

/* 25. pay_salary: 
	This routine is used at the end of the month to pay salaries to employees. 
	The routine inserts the new salary payment records 
	Returns:
		a table of records with the following information for each employee who is paid for the month: 
			employee identifier, name, status (either part-time or full-time), number of work days for the month, 
			number of work hours for the month, hourly rate, monthly salary, and salary amount paid. \
		(sorted in ascending order of employee identifier) 
		For a part-time employee, the values for number of work days for the month and monthly salary should be null.
		For a full-time employees, the values for number of work hours for the month and hourly rate should be null. 
*/
CREATE OR REPLACE FUNCTION pay_salary()
RETURNS TABLE(employee_id INT, name TEXT, emp_status TEXT, num_work_days INT, 
num_work_hours INT, hourly_rate NUMERIC, monthly_salary NUMERIC, salary_amount_paid NUMERIC) AS $$
	DECLARE
		--gets a cursor from the Employees table sorted in ascending order
		emp_curs CURSOR FOR (SELECT * FROM Employees ORDER BY eid ASC);
		emp_record RECORD;
		is_fulltime BOOLEAN;
		payment_info RECORD;
		--declare variables for insertion into Pay_slips_for
		emp_id INT;
		payment_date DATE;
		info_work_hours INT;
		info_work_days INT;
		pay_amt NUMERIC;
	BEGIN

		--start a loop through employees and check their payment information
		OPEN emp_curs;
		LOOP
			FETCH emp_curs INTO emp_record;
			EXIT WHEN NOT FOUND;
			--get data that does not matter if employee is full-time or part-time
			employee_id := emp_record.eid;
			emp_id := emp_record.eid;
			SELECT CURRENT_DATE INTO payment_date;
			name := emp_record.ename;
			--first, check if the employee is a fulltime employee
			is_fulltime := (SELECT 1 FROM Full_Time_Emp WHERE eid = employee_id) IS NOT NULL;
			IF is_fulltime THEN
				--get the fulltime salary info
				SELECT * INTO payment_info FROM full_time_salary_info(employee_id);
				emp_status := 'Full-time';
				num_work_days := payment_info.days_worked;
				--info_work_days := payment_info.days_worked;
        		SELECT days_worked FROM full_time_salary_info(employee_id) INTO info_work_days;
				num_work_hours := NULL;
				info_work_hours := NULL;
				hourly_rate := NULL;
				SELECT ft.monthly_salary FROM Full_Time_Emp ft WHERE ft.eid = employee_id INTO monthly_salary;
				salary_amount_paid := payment_info.salary_amount;
				pay_amt := payment_info.salary_amount;

			ELSE
				SELECT * INTO payment_info FROM part_time_salary_info(employee_id);
				emp_status := 'Part-time';
				num_work_days := NULL;
				info_work_days := NULL;
				num_work_hours := payment_info.hours_worked;
				--info_work_hours := payment_info.hours_worked;
        		SELECT hours_worked FROM part_time_salary_info(employee_id) INTO info_work_hours;
				SELECT pt.hourly_rate FROM Part_Time_Emp pt WHERE pt.eid = employee_id INTO hourly_rate;
				monthly_salary := NULL;
				salary_amount_paid := payment_info.salary_amount;
				pay_amt := payment_info.salary_amount;
			END IF;
			INSERT INTO Pay_slips_for Values(emp_id, payment_date, info_work_hours, info_work_days, pay_amt);
			RETURN NEXT;
		END LOOP;
		CLOSE emp_curs;
	END;
$$ LANGUAGE plpgsql;

--calc the number of hours for the month part time employee, for provided eid
CREATE OR REPLACE FUNCTION part_time_salary_info(IN employee_id INT, OUT hours_worked INT, OUT salary_amount NUMERIC)
RETURNS RECORD AS $$
	DECLARE
		curr_timestamp TIMESTAMP;
		curr_month TIMESTAMP;
		employee_hourly_rate NUMERIC;
		salary_amount_paid NUMERIC;
	BEGIN
		SELECT CURRENT_TIMESTAMP INTO curr_timestamp;
		--check if the employee is a part time employee
		IF NOT EXISTS(SELECT 1 FROM Part_Time_Emp WHERE eid = employee_id) THEN
			RAISE EXCEPTION 'Employee is not a Part Time Employee';
		END IF;

	SELECT hourly_rate FROM Part_Time_Emp WHERE employee_id = eid INTO employee_hourly_rate;

		curr_month := date_trunc('month', curr_timestamp);
		SELECT coalesce(SUM(EXTRACT(epoch FROM Sessions.end_time - Sessions.start_time) / 3600), 0)
		FROM Sessions
		WHERE Sessions.conducting_instructor = employee_id
		--check for sessions conducted in the current month
		AND date_trunc('month', Sessions.s_date) = curr_month
    INTO hours_worked;
		
		salary_amount := hours_worked * employee_hourly_rate;
	END;
$$ LANGUAGE plpgsql;


--calc number of days for full time employee for the provided eid
--The salary amount is given by the product of the employee’s monthly salary and the ratio given by the number of work days for the month to the number of days in the month. 
--first work day = join date if join date is within month of payment, else 1
--last work day = day of departure if within month of payment else 30
--check within month of payment: join/depart month = curr month
CREATE OR REPLACE FUNCTION full_time_salary_info(IN employee_id INT, OUT days_worked INT, OUT salary_amount NUMERIC)
RETURNS RECORD AS $$
	DECLARE
		first_work_day INT;
		last_work_day INT;
		join_date DATE;
		depart_date DATE;
		curr_date DATE;
		employee_monthly_salary NUMERIC;
		days_in_month NUMERIC;
		num_work_days NUMERIC;
		salary_amount_paid NUMERIC;
		joined_within_curr_month BOOLEAN;
	BEGIN
		SELECT CURRENT_DATE INTO curr_date;
		--check if the employee is a full time employee
		IF NOT EXISTS(SELECT 1 FROM Full_Time_Emp WHERE eid = employee_id) THEN
			RAISE EXCEPTION 'Employee is not a Full Time Employee';
		END IF;

		SELECT monthly_salary FROM Full_Time_Emp WHERE employee_id = eid INTO employee_monthly_salary;
		
		SELECT coalesce(DATE_PART('days', DATE_TRUNC('month', NOW()) + '1 MONTH'::INTERVAL - '1 DAY'::INTERVAL)::INTEGER, 0) INTO days_in_month;
		--check if employee joined within month of payment
		SELECT e.join_date FROM Employees e WHERE eid = employee_id INTO join_date;
		joined_within_curr_month := (date_trunc('month', join_date) = date_trunc('month', curr_date));
		IF joined_within_curr_month THEN
			SELECT EXTRACT(DAY FROM join_date)::INTEGER INTO first_work_day;
		ELSE
			first_work_day := 1;
		END IF;
		--check if employee has departed within month of payment
		SELECT e.depart_date FROM Employees e WHERE employee_id = eid INTO depart_date;
		--if depart_date is not null, means that the employee has departed within the month
		--extract the day of departure 
		IF depart_date IS NOT NULL THEN
			SELECT EXTRACT(DAY from depart_date)::INTEGER INTO last_work_day;
		ELSE
			last_work_day := days_in_month;
		END IF;

		days_worked := last_work_day - first_work_day + 1;
    	num_work_days := last_work_day - first_work_day + 1;
		salary_amount := (SELECT ROUND(employee_monthly_salary::NUMERIC / days_in_month * num_work_days, 2));
	END;
$$ LANGUAGE plpgsql;

/** 26. promote_courses: 
    This routine is used to identify potential course offerings that could be of interest to inactive customers. 
    A customer is classified as an active customer if 
        the customer has registered for some course offering in the last six months (inclusive of the current month); 
        otherwise, the customer is considered to be inactive customer. 
    A course area A is of interest to a customer C if 
        there is some course offering in area A among the three most recent course offerings registered by C. 
    If a customer has not yet registered for any course offering, we assume that every course area is of interest to that customer. 
    RETURNS:
        a table of records consisting of the following information for each inactive customer: 
            customer identifier, customer name, course area A that is of interest to the customer,
            course identifier of a course C in area A, course title of C, 
            launch date of course offering of course C that still accepts registrations, 
            course offering’s registration deadline, and fees for the course offering. 
        The output is sorted in ascending order of customer identifier and course offering’s registration deadline. 
**/
CREATE OR REPLACE FUNCTION promote_courses()
RETURNS TABLE(
    cid INT, cname TEXT, course_area TEXT, course_id INT, course_title TEXT, launch_date DATE, deadline DATE, fees NUMERIC
) AS $$
    WITH date_range as (
        SELECT date_trunc('month', CURRENT_DATE) + interval '1 month' - interval '1 day' - interval '6 months' as cutoff_date
    ), Active_customers AS (
        SELECT DISTINCT cust_id, cust_name
        FROM Customers
        LEFT OUTER JOIN Registers ON Customers.cust_id = Registers.owned_by
        JOIN date_range ON Registers.registration_date > date_range.cutoff_date
        UNION 
        SELECT DISTINCT cust_id, cust_name
        FROM Customers
        LEFT OUTER JOIN Redeems on Customers.cust_id = Redeems.owned_by
        JOIN date_range ON Redeems.redeem_date > date_range.cutoff_date
    ), Inactive_customers AS (
        SELECT DISTINCT cust_id, cust_name, course_id, launch_date, registration_date as activity_date
        FROM Customers
        JOIN Registers ON Customers.cust_id = Registers.owned_by
        WHERE cust_id NOT IN (SELECT cust_id FROM Active_customers)
        UNION 
        SELECT DISTINCT cust_id, cust_name, course_id, launch_date, redeem_date as activity_date
        FROM Customers
        JOIN Redeems on Customers.cust_id = Redeems.owned_by
        WHERE cust_id NOT IN (SELECT cust_id FROM Active_customers)
    ), Course_Interests AS (
        SELECT DISTINCT cust_id, cust_name, Courses.area_name
        FROM (
            SELECT Inactive_customers.*, rank() OVER (
                PARTITION BY cust_id ORDER BY activity_date DESC)
            FROM Inactive_customers
        ) AS rank_filter
        JOIN Courses USING (course_id)
        WHERE rank_filter.Rank <= 3
        UNION
        SELECT DISTINCT cust_id, cust_name, Course_Areas.area_name
        FROM (
            SELECT DISTINCT cust_id, cust_name
            FROM Customers
            EXCEPT
            SELECT DISTINCT cust_id, cust_name
            FROM Active_customers
            EXCEPT
            SELECT DISTINCT cust_id, cust_name
            FROM Inactive_customers
        ) AS New_Customers
        CROSS JOIN Course_Areas
    ), Interesting_courses AS (
        SELECT Courses.area_name, Courses.course_id, Courses.title, Offerings.launch_date, Offerings.registration_deadline, Offerings.fees, 
            rank() OVER (PARTITION BY Offerings.registration_deadline ORDER BY Offerings.registration_deadline ASC)
        FROM Available_course_offerings AS Offerings
        JOIN Courses USING (course_id)
        WHERE Offerings.registration_deadline >= CURRENT_DATE
    )
    SELECT cust_id, cust_name, area_name, course_id, title, launch_date, registration_deadline, fees
    FROM Course_Interests
    JOIN Interesting_courses USING (area_name)
    ORDER BY cust_id ASC, registration_deadline ASC;
$$ LANGUAGE SQL;

/**
  27. top packages
    This routine is used to find the top N course packages in terms of the total-number of packages sold for this year
        (i.e., the package’s start date is within this year). 
    INPUTS:
        positive integer number N.
    RETURNS:
        a table of records consisting of the following information for each of the top N course packages:
            package identifier, number of included free course sessions, price of package, 
            start date, end date, and number of packages sold. 
    The output is sorted in descending order of number of packages sold followed by descending order of price of package. 
    In the event that there are multiple packages that tie for the top Nth position, all these packages should be included in the output records; 
        thus, the output table could have more than N records. 
    It is also possible for the output table to have fewer than N records if N is larger than the number of packages launched this year.
**/
CREATE OR REPLACE FUNCTION top_packages(IN top_n INT)
RETURNS TABLE(
    package_id INT, num_free_sessions INT, package_price NUMERIC, start_date DATE, end_date DATE, num_sold BIGINT
) AS $$
	/* number of package n sold = number of package n bought by customer */
	/* find number of sales per package */
	WITH Sales_per_package AS (
		SELECT Course_packages.*, COUNT(Buys.*) as num_sold
		FROM Course_packages
		JOIN Buys USING (package_id)
		WHERE date_trunc('year', Course_packages.sale_start_date) = date_trunc('year', CURRENT_DATE)
		GROUP BY Course_packages.package_id
		ORDER BY num_sold DESC
	)
	SELECT package_id, num_free_registrations as num_free_sessions, price as package_price, 
		sale_start_date as start_date, sale_end_date as end_date, num_sold
	FROM Sales_per_package SP
	WHERE SP.num_sold >= (
		SELECT num_sold FROM sales_per_package ORDER BY num_sold DESC LIMIT 1 OFFSET top_n-1
		)
	;
$$ LANGUAGE SQL;

/* 28. popular_courses: 
	This routine is used to find the popular courses offered this year (i.e., start date is within this year). 
	A course is popular if
		1. the course has at least two offerings this year, 
		2. for every pair of offerings of the course this year, 
			the offering with the later start date has a higher number of registrations than that of the offering with the earlier start date.
	RETURNS:
		a table of records for each popular course:
			course identifier, course title, course area, number of offerings this year, 
			and number of registrations for the latest offering this year. 
		Sorted by (Number of registrations for the latest offering this year) DESC, (course identifier) ASC. */
CREATE OR REPLACE FUNCTION popular_courses()
RETURNS TABLE(out_course_id INT, course_title TEXT, course_area TEXT, num_offerings INT, num_reg_latest INT)
AS $$
  DECLARE
      this_year INT;
      prv_num_reg NUMERIC;
	  curr_num_reg NUMERIC;
      prv_course_id INT;
      is_popular boolean;
      curs refcursor;
      r RECORD;
  BEGIN
      prv_course_id := -1;
      prv_num_reg := -1;
      this_year := (SELECT DATE_PART('year', CURRENT_DATE));

      DROP TABLE IF EXISTS sessions_regs;
      DROP TABLE IF EXISTS offering_regs;

      CREATE TEMP TABLE sessions_regs AS
      SELECT COUNT(DISTINCT owned_by) AS num_reg_session, sid 
      FROM Registers 
      GROUP BY sid; /* count num reg for a session */

      CREATE TEMP TABLE offering_regs AS (
          SELECT SUM(num_reg_session) AS num_reg, O.course_id, O.launch_date
          FROM (Sessions S INNER JOIN Offerings O ON S.course_id = O.course_id AND S.launch_date = O.launch_date) NATURAL JOIN sessions_regs 
          WHERE (SELECT DATE_PART('year', O.start_date)) = this_year
          /* count num regs for course offering this year */
          GROUP BY O.course_id, O.launch_date
          ORDER BY O.start_date ASC, num_reg DESC
      );
	
	OPEN curs FOR (
		SELECT course_id, launch_date 
		FROM offering_regs 
		WHERE course_id IN (
			SELECT course_id FROM offering_regs GROUP BY course_id HAVING COUNT(course_id) >= 2
		)
	);
	LOOP
		FETCH curs INTO r;
		EXIT WHEN NOT FOUND;
		/* if course is not popular, do nothing */
		CONTINUE WHEN NOT is_popular AND r.course_id = prv_course_id; 
		curr_num_reg := (SELECT num_reg FROM offering_regs WHERE r.course_id = course_id);
		IF (prv_course_id <> -1 AND r.course_id <> prv_course_id AND is_popular) THEN
			/* end of prev course id and prev course is popular */
			out_course_id := r.course_id;
			SELECT title, course_area INTO course_title, course_area FROM Courses WHERE course_id = r.course_id;
			num_offerings := (SELECT COUNT(course_id) FROM offering_regs WHERE course_id = r.course_id);
			num_reg_latest := prv_num_reg;
			/* next course id */
			prv_course_id := r.course_id;
		ELSIF (prv_course_id = -1 OR prv_course_id <> r.course_id) THEN
			/*  initialise */
			prv_course_id := r.course_id;
			prv_num_reg := curr_num_reg;
			is_popular := TRUE;
		ELSIF (prv_num_reg < curr_num_reg AND r.course_id = prv_course_id) THEN
			prv_num_reg := curr_num_reg; /* if higher, update. Entries are ordered in asc start date */
		ELSE
			/* there's a pair with prv >= next */
			is_popular := FALSE;
		END IF;
		RETURN NEXT;
      END LOOP;
      CLOSE curs;

      DROP TABLE offering_regs;
      DROP TABLE sessions_regs;
  END;
$$ LANGUAGE plpgsql;

/** 29. view_summary_report: 
    This routine is used to view a monthly summary report of the company’s sales and expenses for a specified number of months.
    INPUT:
        a number of months (say N) 
    RETURNS:
        a table of records consisting of the following information for each of the last N months (starting from the current month): 
            month and year, total salary paid for the month, total amount of sales of course packages for the month, 
            total registration fees paid via credit card payment for the month, total amount of refunded registration fees (due to cancellations) for the month,
            and total number of course registrations via course package redemptions for the month. 
        For example, if the number of specified months is 3 and the current month is January 2021, the output will consist of
            one record for each of the following three months: January 2021, December 2020, and November 2020.
**/
CREATE OR REPLACE FUNCTION view_summary_report(N INT)
RETURNS TABLE(
    month_year DATE, total_salary_paid FLOAT, total_packages_sales NUMERIC, total_reg_fees NUMERIC,
    total_refunded_fees FLOAT, total_redemptions BIGINT
) AS $$
    --i.e. for each month, have to get the total info
    DECLARE
        start_of_month DATE := (SELECT date_trunc('month', CURRENT_DATE));
        end_of_month DATE := (SELECT date_trunc('month', CURRENT_DATE) + interval '1 month' - interval '1 day');
    BEGIN
    RETURN QUERY
        WITH date_range AS (
            SELECT start_date, end_date
            FROM (
                SELECT generate_series(
                    start_of_month::timestamp, start_of_month - (N-1)*interval '1 month', -1 * interval '1 month'
                )::date AS start_date
            ) AS Start_Month
            LEFT JOIN (
                SELECT generate_series(
                    end_of_month::timestamp, end_of_month - (N-1)*interval '1 month', -1 * interval '1 month'
                )::date AS end_date
            ) AS End_Month ON date_trunc('month', start_date) = date_trunc('month', end_date)
        )
        SELECT 
            end_date AS month_year,
            COALESCE(sum(Pay_slips_for.amount), 0) as total_salary_paid,
            COALESCE(sum(Buy_records.price), 0) as total_packages_sales,
            COALESCE(sum(Registration_records.fees), 0) as total_reg_fees,
            COALESCE(sum(Refund_records.refund_amt), 0) as total_refunded_fees,
            COALESCE(count(Redeem_records.redeem_date), 0) as total_redemptions
        FROM date_range
        LEFT OUTER JOIN Pay_slips_for ON date_trunc('month', start_date) = date_trunc('month', payment_date)
        LEFT OUTER JOIN (
            SELECT Course_packages.price, Buys.buy_date
            FROM Buys
            JOIN Course_packages USING (package_id)
            WHERE buy_date <= end_of_month
            ) AS Buy_records ON date_trunc('month', start_date) = date_trunc('month', buy_date)
        LEFT OUTER JOIN (
            SELECT Offerings.fees, Registers.registration_date
            FROM Registers
            JOIN Offerings USING (course_id, launch_date)
            WHERE registration_date <= end_of_month
        ) AS Registration_records ON date_trunc('month', start_date) = date_trunc('month', registration_date)
        LEFT OUTER JOIN (
            SELECT Cancels.refund_amt, Cancels.cancel_date
            FROM Cancels
            WHERE cancel_date <= end_of_month
        ) AS Refund_records ON date_trunc('month', start_date) = date_trunc('month', cancel_date)
        LEFT OUTER JOIN (
            SELECT redeem_date
            FROM Redeems
            WHERE redeem_date <= end_of_month
        ) AS Redeem_records ON date_trunc('month', start_date) = date_trunc('month', redeem_date)
        GROUP BY (start_date);
    END;
$$ LANGUAGE plpgsql;

/** 30. view_manager_report
    This routine is used to view a report on the sales generated by each manager.
    No Input 
    Returns: 
        Table of records for each manager:
            manager name,
            total number of course areas that are managed by the manager, 
            total number of course offerings managed by the manager (with offering’s end date is within this year),
            total net registration fees for all the course offerings that ended this year that are managed by the manager,
                * sum of the total registration fees paid for the course offering via credit card payment 
                * (excluding any refunded fees due to cancellations) 
            the course offering title (i.e., course title) that has the highest total net registration fees 
                among all the course offerings that ended this year that are managed by the manager;
            if there are ties, list all these top course offering titles.
    --one output record for each manager in the company
    --if there are ties in top course offerings, return a list (array) of the titles
**/
CREATE OR REPLACE FUNCTION view_manager_report()
RETURNS TABLE (
	manager_name TEXT,
	num_course_areas_managed BIGINT,
	num_course_offerings_managed BIGINT, 
	total_net_reg_fees NUMERIC,
	top_course_offering TEXT[]
	)
AS $$
    WITH Manages AS (
        SELECT Employees.eid, Employees.ename, count(Course_areas.area_name) as num_course_areas_managed
        FROM Course_areas
        RIGHT OUTER JOIN Managers ON Course_areas.manager_id = Managers.eid
        JOIN Employees USING (eid)
        GROUP BY Employees.eid
        ORDER BY Employees.ename ASC
    ), Managed_offerings AS (
        SELECT manager_id, Courses.title, 
            Offerings.course_id, Offerings.launch_date, 
            sum(Offerings.course_id) as num_course_offerings_managed
        FROM Offerings
        JOIN Courses USING (course_id)
        JOIN Course_areas USING (area_name)
        WHERE date_trunc('year', Offerings.end_date) = date_trunc('year', CURRENT_DATE)
        GROUP BY (manager_id, Courses.title, Offerings.course_id, Offerings.launch_date)
    ), course_net_registration_fees AS (
        SELECT
            MO.manager_id,
            MO.title,
            MO.course_id,
            MO.launch_date,
            MO.num_course_offerings_managed,
            COALESCE(registration_fees, 0) + COALESCE(redemption_fees, 0) as net_registration_fees
        FROM Managed_offerings AS MO
        FULL OUTER JOIN (
            SELECT O.course_id, O.launch_date, sum(O.fees) as registration_fees
            FROM Offerings O
            JOIN Registers USING (course_id, launch_date)
            WHERE date_trunc('year', O.end_date) = date_trunc('year', CURRENT_DATE)
            GROUP BY (O.course_id, O.launch_date)
        ) AS TRF1 USING (course_id, launch_date)
        FULL OUTER JOIN (
            SELECT O.course_id, O.launch_date, sum(round(CP.price / CP.num_free_registrations, 2)) as redemption_fees
            FROM Offerings O
            JOIN Redeems USING (course_id, launch_date)
            JOIN Buys USING (package_id, buy_date)
            JOIN Course_packages AS CP USING (package_id)
            WHERE date_trunc('year', O.end_date) = date_trunc('year', CURRENT_DATE)
            GROUP BY (O.course_id, O.launch_date)
        ) AS TRF2 USING (course_id, launch_date)
    )
    SELECT 
        Manages.ename as manager_name, Manages.num_course_areas_managed,
        CF1.num_course_offerings_managed, 
        sum(CF1.net_registration_fees) as total_net_reg_fees,
        array_agg(CF1.title) as top_course_offering
    FROM course_net_registration_fees CF1
    JOIN (
        SELECT CF.manager_id, max(CF.net_registration_fees) as top_registration_fee
        FROM course_net_registration_fees CF
        GROUP BY CF.manager_id
    ) AS CF2 ON CF1.manager_id = CF2.manager_id and CF1.net_registration_fees >= CF2.top_registration_fee
    JOIN Manages ON CF1.manager_id = Manages.eid
    GROUP BY (Manages.ename, Manages.num_course_areas_managed, CF1.num_course_offerings_managed)
    ORDER BY Manages.ename ASC;
$$ LANGUAGE sql;